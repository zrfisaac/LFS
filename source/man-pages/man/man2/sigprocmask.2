.\" Copyright (c) 2005 Michael Kerrisk
.\" based on earlier work by faith@cs.unc.edu and
.\" Mike Battersby <mib@deakin.edu.au>
.\"
.\" SPDX-License-Identifier: Linux-man-pages-copyleft
.\"
.\" 2005-09-15, mtk, Created new page by splitting off from sigaction.2
.\"
.TH sigprocmask 2 2024-05-02 "Linux man-pages (unreleased)"
.SH NAME
sigprocmask, rt_sigprocmask \- examine and change blocked signals
.SH LIBRARY
Standard C library
.RI ( libc ", " \-lc )
.SH SYNOPSIS
.B #include <signal.h>
.P
.nf
/* Prototype for the glibc wrapper function */
.BI "int sigprocmask(int " how ", const sigset_t *_Nullable restrict " set ,
.BI "                           sigset_t *_Nullable restrict " oldset );
.P
.BR "#include <signal.h>" "           /* Definition of " SIG_* " constants */"
.BR "#include <sys/syscall.h>" "      /* Definition of " SYS_* " constants */"
.B #include <unistd.h>
.P
/* Prototype for the underlying system call */
.BI "int syscall(SYS_rt_sigprocmask, int " how ,
.BI "                           const kernel_sigset_t *_Nullable " set ,
.BI "                           kernel_sigset_t *_Nullable " oldset ,
.BI "                           size_t " sigsetsize );
.P
/* Prototype for the legacy system call */
.BI "[[deprecated]] int syscall(SYS_sigprocmask, int " how ,
.BI "                           const old_kernel_sigset_t *_Nullable " set ,
.BI "                           old_kernel_sigset_t *_Nullable " oldset );
.fi
.P
.RS -4
Feature Test Macro Requirements for glibc (see
.BR feature_test_macros (7)):
.RE
.P
.BR sigprocmask ():
.nf
    _POSIX_C_SOURCE
.fi
.SH DESCRIPTION
.BR sigprocmask ()
is used to fetch and/or change the signal mask of the calling thread.
The signal mask is the set of signals whose delivery is currently
blocked for the caller
(see also
.BR signal (7)
for more details).
.P
The behavior of the call is dependent on the value of
.IR how ,
as follows.
.TP
.B SIG_BLOCK
The set of blocked signals is the union of the current set and the
.I set
argument.
.TP
.B SIG_UNBLOCK
The signals in
.I set
are removed from the current set of blocked signals.
It is permissible to attempt to unblock a signal which is not blocked.
.TP
.B SIG_SETMASK
The set of blocked signals is set to the argument
.IR set .
.P
If
.I oldset
is non-NULL, the previous value of the signal mask is stored in
.IR oldset .
.P
If
.I set
is NULL, then the signal mask is unchanged (i.e.,
.I how
is ignored),
but the current value of the signal mask is nevertheless returned in
.I oldset
(if it is not NULL).
.P
A set of functions for modifying and inspecting variables of type
.I sigset_t
("signal sets") is described in
.BR sigsetops (3).
.P
The use of
.BR sigprocmask ()
is unspecified in a multithreaded process; see
.BR pthread_sigmask (3).
.SH RETURN VALUE
.BR sigprocmask ()
returns 0 on success.
On failure, \-1 is returned and
.I errno
is set to indicate the error.
.SH ERRORS
.TP
.B EFAULT
The
.I set
or
.I oldset
argument points outside the process's allocated address space.
.TP
.B EINVAL
Either the value specified in
.I how
was invalid or the kernel does not support the size passed in
.I sigsetsize.
.SH VERSIONS
.SS C library/kernel differences
The kernel's definition of
.I sigset_t
differs in size from that used
by the C library.
In this manual page, the former is referred to as
.I kernel_sigset_t
(it is nevertheless named
.I sigset_t
in the kernel sources).
.P
The glibc wrapper function for
.BR sigprocmask ()
silently ignores attempts to block the two real-time signals that
are used internally by the NPTL threading implementation.
See
.BR nptl (7)
for details.
.P
The original Linux system call was named
.BR sigprocmask ().
However, with the addition of real-time signals in Linux 2.2,
the fixed-size, 32-bit
.I sigset_t
(referred to as
.I old_kernel_sigset_t
in this manual page)
type supported by that system call was no longer fit for purpose.
Consequently, a new system call,
.BR rt_sigprocmask (),
was added to support an enlarged
.I sigset_t
type
(referred to as
.I kernel_sigset_t
in this manual page).
The new system call takes a fourth argument,
.IR "size_t sigsetsize" ,
which specifies the size in bytes of the signal sets in
.I set
and
.IR oldset .
This argument is currently required to have a fixed architecture specific value
(equal to
.IR sizeof(kernel_sigset_t) ).
.\" sizeof(kernel_sigset_t) == _NSIG / 8,
.\" which equals to 8 on most architectures, but e.g. on MIPS it's 16.
.P
The glibc
.BR sigprocmask ()
wrapper function hides these details from us, transparently calling
.BR rt_sigprocmask ()
when the kernel provides it.
.\"
.SH STANDARDS
POSIX.1-2008.
.SH HISTORY
POSIX.1-2001.
.SH NOTES
It is not possible to block
.BR SIGKILL " or " SIGSTOP .
Attempts to do so are silently ignored.
.P
Each of the threads in a process has its own signal mask.
.P
A child created via
.BR fork (2)
inherits a copy of its parent's signal mask;
the signal mask is preserved across
.BR execve (2).
.P
If
.BR SIGBUS ,
.BR SIGFPE ,
.BR SIGILL ,
or
.B SIGSEGV
are generated
while they are blocked, the result is undefined,
unless the signal was generated by
.BR kill (2),
.BR sigqueue (3),
or
.BR raise (3).
.P
See
.BR sigsetops (3)
for details on manipulating signal sets.
.P
Note that it is permissible (although not very useful) to specify both
.I set
and
.I oldset
as NULL.
.SH SEE ALSO
.BR kill (2),
.BR pause (2),
.BR sigaction (2),
.BR signal (2),
.BR sigpending (2),
.BR sigsuspend (2),
.BR pthread_sigmask (3),
.BR sigqueue (3),
.BR sigsetops (3),
.BR signal (7)
